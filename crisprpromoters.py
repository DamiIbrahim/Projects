# -*- coding: utf-8 -*-
"""CRISPRpromoters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bjYa-ITtKqLQeLxmPUQujaDuX-LIiFoG
"""

# Credit to Arpitha and Savi

'''
This program accepts a fasta file as STDIN and outputs the consensus sequence and associated profile score as STDOUT.
The score is the sum of the entropies across each position in the final profile.
'''

class CommandLine() :
    '''
    Handle the command line, usage and help requests.
    CommandLine uses argparse, now standard in 2.7 and beyond.
    it implements a standard command line argument parser with various argument options,
    a standard usage and help, and an error termination mechanism do-usage_and_die.
    attributes:
    all arguments received from the commandline using .add_argument will be
    avalable within the .args attribute of object instantiated from CommandLine.
    For example, if myCommandLine is an object of the class, and requiredbool was
    set as an option using add_argument, then myCommandLine.args.requiredbool will
    name that option.
    '''

    def __init__(self, inOpts=None) :
        '''
        CommandLine constructor.
        Implements a parser to interpret the command line argv string using argparse.
        '''
        import argparse
        self.parser = argparse.ArgumentParser(
            description='Program prolog - a brief description of what this thing does',
            epilog='Program epilog - some other stuff you feel compelled to say',
            add_help=True,  # default is True
            prefix_chars='-',
            usage='%(prog)s [options] -option1[default] <input >output'
        )
        self.parser.add_argument('-i', '--iterations', nargs='?', type=int, default=1, action='store',
                                 help='iterations')
        self.parser.add_argument('-p', '--pseudocount', nargs='?', type=float, default=1, action='store',
                                 help='pseudocount')
        self.parser.add_argument('-k', '--kmer', nargs='?', type=int, default=.01, action='store',
                                 help='kmer length')
        self.parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1')
        if inOpts is None :
            self.args = self.parser.parse_args()
        else :
            self.args = self.parser.parse_args(inOpts)

import sys


class FastAreader :
    '''FastAreader program provided by the professor. '''

    def __init__(self, fname='') :
        '''contructor: saves attribute fname '''

        self.fname = fname
        self.fileH = None

    def doOpen(self) :
        if self.fname == '' :
            return sys.stdin
        else :
            return open(self.fname)

    def readFasta(self) :

        header = ''
        sequence = ''

        with self.doOpen() as self.fileH :

            header = ''
            sequence = ''

            # skip to first fasta header
            line = self.fileH.readline()
            while not line.startswith('>') :
                line = self.fileH.readline()
            header = line[1 :].rstrip()

            for line in self.fileH :
                if line.startswith('>') :
                    yield header, sequence
                    header = line[1 :].rstrip()
                    sequence = ''
                else :
                    sequence += ''.join(line.rstrip().split()).upper()

        yield header, sequence

import math
import random
import numpy as np

class CRISPR:
    def __init__(self, iter, PC, kmers):
        '''
        Initializes the iterations, pseudocount and kmer length.
        Creates an empty list for the motif, count, and profile matrix.
        Initializes the probability for each base
        '''
        self.iter = int(iter)
        self.PC = int(PC)
        self.kmers = kmers
        self.motifMatrix = []
        self.countMatrix = []
        self.profileMatrix = []
        self.genome = []
        self.conSeq = None
        self.probability_A = 0
        self.probability_C = 0
        self.probability_T = 0
        self.probability_G = 0

    def randMotif(self):
        '''
        randomly selects a motif on the genome and adds to the motif list. From Chris OH
        '''
        motifList = []
        for seq in self.genome:
            start = random.randint(0, len(seq) - self.kmers) # picks a random position in the genome to start the kmer
            end = int(start) + self.kmers
            motif = list(seq[start:end])
            motifList.append(motif) #add the kmer to a list
        self.motifMatrix = np.array(motifList) #make list an array
        return self.motifMatrix
    def getIterations(self):
        '''
        returns the number of iterations
        '''
        return self.iter

    def arrayMotif(self, nucList):
        '''
        Converts the motif matrix into an array so I can later use the array to count the columns
        '''
        motifList = []
        for i in range(len(nucList)):
            code = list(nucList[i])
            motifList.append(code)
        self.motifMatrix = np.array(motifList)
        return self.motifMatrix

    def countsMatrix(self):
        '''
        counts the number of each base in each column, plus the pseudocount and puts it in the count matrix
        '''
        A_list = []; T_list = []; C_list = []; G_list = []
        for val in range(self.kmers):
            col = self.motifMatrix[:,val] # gets the columns in the motif matrix
            countA = sum(np.char.count(col, 'A'), self.PC) #adds the number of bases in each column plus the pseducount
            countT = sum(np.char.count(col, 'T'), self.PC)
            countC = sum(np.char.count(col, 'C'), self.PC)
            countG = sum(np.char.count(col, 'G'), self.PC)
            A_list.append(countA)
            T_list.append(countT)
            C_list.append(countC)
            G_list.append(countG)
        count_list = [A_list, T_list, G_list, C_list] #puts the count of each base into a list
        self.countMatrix = np.array(count_list) #makes list an array
        return self.countMatrix

    def profilesMatrix(self):
        '''
        calculates the proportion of each base in each column and puts it in the profile matrix
        '''
        A_prob = []; T_prob = []; C_prob = []; G_prob = []
        for val in range(self.kmers):
            col = self.countMatrix[:, val]
            x = sum(col)
            A_prob.append(col[0] / x) # gets the proportion of each base in each column over the total nucleotides
            T_prob.append(col[1] / x)
            C_prob.append(col[2] / x)
            G_prob.append(col[3] / x)
        prob_list = [A_prob, T_prob, C_prob, G_prob] #puts the proportion of each base into a list
        self.profileMatrix = np.array(prob_list) #make the list an array
        return (self.profileMatrix)

    def consensusSeq(self):
        '''
        Finds the consensus sequence by iterating through the kmer length
        and profile matrix. Finds the max probability in each column in the profile
        matrix.
        '''
        seq = []
        for val in range(self.kmers):
            col = self.profileMatrix[:, val]
            base = max(col)
            if base == col[0]:  #adds the highest probability of each base to the consensus sequence
                seq.append('A')
            elif base == col[1]:
                seq.append('T')
            elif base == col[2]:
                seq.append('C')
            else:
                seq.append('G')
        self.conSeq = ''.join(seq)
        return self.conSeq

    def relativeE(self):
        '''
        calculates the relative entropy score based on the profile matrix and the total number of bases in the genome.
        '''
        countRE = 0
        for val in range(self.kmers):
            col = self.profileMatrix[:, val]
            probA = col[0]; probT = col[1]; probC = col[2]; probG = col[3]

            aProb = probA * math.log2(probA / self.probability_A) # calculates the entropy score for each base
            tProb = probT * math.log2(probT / self.probability_T)
            cProb = probC * math.log2(probC / self.probability_C)
            gProb = probG * math.log2(probG / self.probability_G)
            scoreRE = (aProb + tProb + cProb + gProb) # adds up all the scores
            countRE += scoreRE
        return countRE

    def motifProb(self, seq):
        '''
        Finds the highest probability out of all the possible kmers in the sequence
        '''
        probDict = {}
        start = 0
        end = self.kmers - 1
        while (end < len(seq)):
            motifSeq = seq[start:end + 1]
            motifProb = 1
            baseNum = 0
            for nuc in motifSeq:
                if nuc == 'A':
                    motifProb = motifProb * self.profileMatrix[0][baseNum]
                elif nuc == 'T':
                    motifProb = motifProb * self.profileMatrix[1][baseNum]
                elif nuc == 'C':
                    motifProb = motifProb * self.profileMatrix[2][baseNum]
                else:
                    motifProb = motifProb * self.profileMatrix[3][baseNum]
            probDict[motifSeq] = motifProb
            start += 1
            end += 1
        finalMotif = max(probDict, key = lambda x: probDict[x])
        return finalMotif

    def calcProb(self, sourceReader):
        '''
        Calculates every nucleotide in the file and all the nucleotides in the final to get the
        probability of each base.
        '''
        countA = 0; countT = 0; countC = 0; countG = 0; genomeCount = 0
        bases = ['A', 'T', 'C', 'G']
        for head, seq in sourceReader.readFasta():
            seq = ''.join(filter(lambda x: x in bases, seq))
            countA += seq.count('A')
            countT += seq.count('T')
            countC += seq.count('C')
            countG += seq.count('G')
            genomeCount += len(seq)
            self.genome.append(seq)

        countA = countA + self.PC
        countT = countT + self.PC
        countC = countC + self.PC
        countG = countG + self.PC
        genomeCount = genomeCount + (4 * self.PC)

        self.probability_A = countA / genomeCount
        self.probability_T = countT / genomeCount
        self.probability_C = countC / genomeCount
        self.probability_G = countG / genomeCount


def main(inFile=None, options=None):
    '''
    Gets the data runs the iterations. Check to see if the score is better or not
    '''
    cl = CommandLine(options)
    sourceReader = FastAreader(inFile)  # setup the Fasta reader Object
    thisCRISPR = CRISPR(cl.args.iterations, cl.args.pseudocount, cl.args.kmer)
    thisCRISPR.calcProb(sourceReader)
    bases = ['A', 'T', 'C', 'G']

    bestMotif = None
    bestScore = math.inf
    for i in range(thisCRISPR.getIterations()):
        prevScore = -math.inf
        thisCRISPR.randMotif() # Get the initial set of random motifs
        thisCRISPR.countsMatrix()
        thisCRISPR.profilesMatrix()
        conSeq = thisCRISPR.consensusSeq()
        relE = thisCRISPR.relativeE()
        while (prevScore != relE):  #Loop through until the score stops changing
            var = relE
            prevScore = var
            x = []
            for head, seq in sourceReader.readFasta():
                seq = ''.join(filter(lambda x : x in bases, seq))
                newM = thisCRISPR.motifProb(seq)
                x.append(newM)
            thisCRISPR.arrayMotif(x)
            thisCRISPR.countsMatrix()
            thisCRISPR.profilesMatrix()
            conSeq = thisCRISPR.consensusSeq()
            relE = thisCRISPR.relativeE()
        if bestMotif is None and bestScore == math.inf: #if statement comparing the motif and score
            bestMotif = conSeq
            bestScore = relE
        else:
            if bestScore < relE:  # if the score stops changing then that is the new best score
                bestMotif = conSeq
                bestScore = relE
    print("Consensus Sequence: {bestMotif}".format(bestMotif=bestMotif))
    print("Best Score: {bestScore}".format(bestScore=bestScore))


if __name__ == "__main__" :
    main(inFile="input.fa", options=["-i=1000", "-p=1", "-k=13"])

main()